{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._onCallWithOptions = exports.decode = exports.encode = exports.HttpsError = exports._onRequestWithOptions = exports.onCall = exports.onRequest = void 0;\n\nvar cors = require(\"cors\");\n\nvar _ = require(\"lodash\");\n\nvar apps_1 = require(\"../apps\");\n\nvar cloud_functions_1 = require(\"../cloud-functions\");\n\nvar logger_1 = require(\"../logger\");\n/**\n * Handle HTTP requests.\n * @param handler A function that takes a request and response object,\n * same signature as an Express app.\n */\n\n\nfunction onRequest(handler) {\n  return _onRequestWithOptions(handler, {});\n}\n\nexports.onRequest = onRequest;\n/**\n * Declares a callable method for clients to call using a Firebase SDK.\n * @param handler A method that takes a data and context and returns a value.\n */\n\nfunction onCall(handler) {\n  return _onCallWithOptions(handler, {});\n}\n\nexports.onCall = onCall;\n/** @hidden */\n\nfunction _onRequestWithOptions(handler, options) {\n  // lets us add __trigger without altering handler:\n  var cloudFunction = function cloudFunction(req, res) {\n    return handler(req, res);\n  };\n\n  cloudFunction.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n    httpsTrigger: {}\n  }); // TODO parse the options\n\n  return cloudFunction;\n}\n\nexports._onRequestWithOptions = _onRequestWithOptions;\n/**\n * Standard error codes and HTTP statuses for different ways a request can fail,\n * as defined by:\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n *\n * This map is used primarily to convert from a client error code string to\n * to the HTTP format error code string and status, and make sure it's in the\n * supported set.\n */\n\nvar errorCodeMap = {\n  ok: {\n    canonicalName: 'OK',\n    status: 200\n  },\n  cancelled: {\n    canonicalName: 'CANCELLED',\n    status: 499\n  },\n  unknown: {\n    canonicalName: 'UNKNOWN',\n    status: 500\n  },\n  'invalid-argument': {\n    canonicalName: 'INVALID_ARGUMENT',\n    status: 400\n  },\n  'deadline-exceeded': {\n    canonicalName: 'DEADLINE_EXCEEDED',\n    status: 504\n  },\n  'not-found': {\n    canonicalName: 'NOT_FOUND',\n    status: 404\n  },\n  'already-exists': {\n    canonicalName: 'ALREADY_EXISTS',\n    status: 409\n  },\n  'permission-denied': {\n    canonicalName: 'PERMISSION_DENIED',\n    status: 403\n  },\n  unauthenticated: {\n    canonicalName: 'UNAUTHENTICATED',\n    status: 401\n  },\n  'resource-exhausted': {\n    canonicalName: 'RESOURCE_EXHAUSTED',\n    status: 429\n  },\n  'failed-precondition': {\n    canonicalName: 'FAILED_PRECONDITION',\n    status: 400\n  },\n  aborted: {\n    canonicalName: 'ABORTED',\n    status: 409\n  },\n  'out-of-range': {\n    canonicalName: 'OUT_OF_RANGE',\n    status: 400\n  },\n  unimplemented: {\n    canonicalName: 'UNIMPLEMENTED',\n    status: 501\n  },\n  internal: {\n    canonicalName: 'INTERNAL',\n    status: 500\n  },\n  unavailable: {\n    canonicalName: 'UNAVAILABLE',\n    status: 503\n  },\n  'data-loss': {\n    canonicalName: 'DATA_LOSS',\n    status: 500\n  }\n};\n/**\n * An explicit error that can be thrown from a handler to send an error to the\n * client that called the function.\n */\n\nvar HttpsError = /*#__PURE__*/function (_Error) {\n  _inherits(HttpsError, _Error);\n\n  function HttpsError(code, message, details) {\n    var _this;\n\n    _classCallCheck(this, HttpsError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(HttpsError).call(this, message)); // A sanity check for non-TypeScript consumers.\n\n    if (code in errorCodeMap === false) {\n      throw new Error(\"Unknown error code: \".concat(code, \".\"));\n    }\n\n    _this.code = code;\n    _this.details = details;\n    _this.httpErrorCode = errorCodeMap[code];\n    return _this;\n  }\n  /** @hidden */\n\n\n  _createClass(HttpsError, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      var details = this.details,\n          status = this.httpErrorCode.canonicalName,\n          message = this.message;\n      return _objectSpread({}, details === undefined ? {} : {\n        details: details\n      }, {\n        message: message,\n        status: status\n      });\n    }\n  }]);\n\n  return HttpsError;\n}(_wrapNativeSuper(Error));\n\nexports.HttpsError = HttpsError;\n/** @hidden */\n// Returns true if req is a properly formatted callable request.\n\nfunction isValidRequest(req) {\n  // The body must not be empty.\n  if (!req.body) {\n    logger_1.warn('Request is missing body.');\n    return false;\n  } // Make sure it's a POST.\n\n\n  if (req.method !== 'POST') {\n    logger_1.warn('Request has invalid method.', req.method);\n    return false;\n  } // Check that the Content-Type is JSON.\n\n\n  var contentType = (req.header('Content-Type') || '').toLowerCase(); // If it has a charset, just ignore it for now.\n\n  var semiColon = contentType.indexOf(';');\n\n  if (semiColon >= 0) {\n    contentType = contentType.substr(0, semiColon).trim();\n  }\n\n  if (contentType !== 'application/json') {\n    logger_1.warn('Request has incorrect Content-Type.', contentType);\n    return false;\n  } // The body must have data.\n\n\n  if (_.isUndefined(req.body.data)) {\n    logger_1.warn('Request body is missing data.', req.body);\n    return false;\n  } // TODO(klimt): Allow only whitelisted http headers.\n  // Verify that the body does not have any extra fields.\n\n\n  var extras = _.omit(req.body, 'data');\n\n  if (!_.isEmpty(extras)) {\n    logger_1.warn('Request body has extra fields.', extras);\n    return false;\n  }\n\n  return true;\n}\n/** @hidden */\n\n\nvar LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\n/** @hidden */\n\nvar UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\n/**\n * Encodes arbitrary data in our special format for JSON.\n * This is exposed only for testing.\n */\n\n/** @hidden */\n\nfunction encode(data) {\n  if (_.isNull(data) || _.isUndefined(data)) {\n    return null;\n  } // Oddly, _.isFinite(new Number(x)) always returns false, so unwrap Numbers.\n\n\n  if (data instanceof Number) {\n    data = data.valueOf();\n  }\n\n  if (_.isFinite(data)) {\n    // Any number in JS is safe to put directly in JSON and parse as a double\n    // without any loss of precision.\n    return data;\n  }\n\n  if (_.isBoolean(data)) {\n    return data;\n  }\n\n  if (_.isString(data)) {\n    return data;\n  }\n\n  if (_.isArray(data)) {\n    return _.map(data, encode);\n  }\n\n  if (_.isObject(data)) {\n    // It's not safe to use _.forEach, because the object might be 'array-like'\n    // if it has a key called 'length'. Note that this intentionally overrides\n    // any toJSON method that an object may have.\n    return _.mapValues(data, encode);\n  } // If we got this far, the data is not encodable.\n\n\n  logger_1.error('Data cannot be encoded in JSON.', data);\n  throw new Error('Data cannot be encoded in JSON: ' + data);\n}\n\nexports.encode = encode;\n/**\n * Decodes our special format for JSON into native types.\n * This is exposed only for testing.\n */\n\n/** @hidden */\n\nfunction decode(data) {\n  if (data === null) {\n    return data;\n  }\n\n  if (data['@type']) {\n    switch (data['@type']) {\n      case LONG_TYPE: // Fall through and handle this the same as unsigned.\n\n      case UNSIGNED_LONG_TYPE:\n        {\n          // Technically, this could work return a valid number for malformed\n          // data if there was a number followed by garbage. But it's just not\n          // worth all the extra code to detect that case.\n          var value = parseFloat(data.value);\n\n          if (_.isNaN(value)) {\n            logger_1.error('Data cannot be decoded from JSON.', data);\n            throw new Error('Data cannot be decoded from JSON: ' + data);\n          }\n\n          return value;\n        }\n\n      default:\n        {\n          logger_1.error('Data cannot be decoded from JSON.', data);\n          throw new Error('Data cannot be decoded from JSON: ' + data);\n        }\n    }\n  }\n\n  if (_.isArray(data)) {\n    return _.map(data, decode);\n  }\n\n  if (_.isObject(data)) {\n    // It's not safe to use _.forEach, because the object might be 'array-like'\n    // if it has a key called 'length'.\n    return _.mapValues(data, decode);\n  } // Anything else is safe to return.\n\n\n  return data;\n}\n\nexports.decode = decode;\n/**\n * Check and verify tokens included in the requests. Once verified, tokens\n * are injected into the callable context.\n *\n * @param {Request} req - Request sent to the Callable function.\n * @param {CallableContext} ctx - Context to be sent to callable function handler.\n * @return {CallableTokenStatus} Status of the token verifications.\n */\n\n/** @hidden */\n\nfunction checkTokens(_x, _x2) {\n  return _checkTokens.apply(this, arguments);\n}\n/** @hidden */\n\n\nfunction _checkTokens() {\n  _checkTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, ctx) {\n    var verifications, appCheck, appCheckToken, authorization, match, idToken, authToken, logPayload, errs;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            verifications = {\n              app: 'MISSING',\n              auth: 'MISSING'\n            };\n            appCheck = req.header('X-Firebase-AppCheck');\n\n            if (!appCheck) {\n              _context2.next = 17;\n              break;\n            }\n\n            verifications.app = 'INVALID';\n            _context2.prev = 4;\n\n            if (apps_1.apps().admin.appCheck) {\n              _context2.next = 7;\n              break;\n            }\n\n            throw new Error('Cannot validate AppCheck token. Please uupdate Firebase Admin SDK to >= v9.8.0');\n\n          case 7:\n            _context2.next = 9;\n            return apps_1.apps().admin.appCheck().verifyToken(appCheck);\n\n          case 9:\n            appCheckToken = _context2.sent;\n            ctx.app = {\n              appId: appCheckToken.appId,\n              token: appCheckToken.token\n            };\n            verifications.app = 'VALID';\n            _context2.next = 17;\n            break;\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t0 = _context2[\"catch\"](4);\n            logger_1.warn('Failed to validate AppCheck token.', _context2.t0);\n\n          case 17:\n            authorization = req.header('Authorization');\n\n            if (!authorization) {\n              _context2.next = 34;\n              break;\n            }\n\n            verifications.auth = 'INVALID';\n            match = authorization.match(/^Bearer (.*)$/);\n\n            if (!match) {\n              _context2.next = 34;\n              break;\n            }\n\n            idToken = match[1];\n            _context2.prev = 23;\n            _context2.next = 26;\n            return apps_1.apps().admin.auth().verifyIdToken(idToken);\n\n          case 26:\n            authToken = _context2.sent;\n            verifications.auth = 'VALID';\n            ctx.auth = {\n              uid: authToken.uid,\n              token: authToken\n            };\n            _context2.next = 34;\n            break;\n\n          case 31:\n            _context2.prev = 31;\n            _context2.t1 = _context2[\"catch\"](23);\n            logger_1.warn('Failed to validate auth token.', _context2.t1);\n\n          case 34:\n            logPayload = {\n              verifications: verifications,\n              'logging.googleapis.com/labels': {\n                'firebase-log-type': 'callable-request-verification'\n              }\n            };\n            errs = [];\n\n            if (verifications.app === 'INVALID') {\n              errs.push('AppCheck token was rejected.');\n            }\n\n            if (verifications.auth === 'INVALID') {\n              errs.push('Auth token was rejected.');\n            }\n\n            if (errs.length == 0) {\n              logger_1.info('Callable request verification passed', logPayload);\n            } else {\n              logger_1.warn(\"Callable request verification failed: \".concat(errs.join(' ')), logPayload);\n            }\n\n            return _context2.abrupt(\"return\", verifications);\n\n          case 40:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[4, 14], [23, 31]]);\n  }));\n  return _checkTokens.apply(this, arguments);\n}\n\nvar corsHandler = cors({\n  origin: true,\n  methods: 'POST'\n});\n/** @hidden */\n\nfunction _onCallWithOptions(handler, options) {\n  var func = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res) {\n      var context, tokenStatus, instanceId, data, result, responseBody, status, body;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n\n              if (isValidRequest(req)) {\n                _context.next = 4;\n                break;\n              }\n\n              logger_1.error('Invalid request, unable to process.');\n              throw new HttpsError('invalid-argument', 'Bad Request');\n\n            case 4:\n              context = {\n                rawRequest: req\n              };\n              _context.next = 7;\n              return checkTokens(req, context);\n\n            case 7:\n              tokenStatus = _context.sent;\n\n              if (!(tokenStatus.app === 'INVALID' || tokenStatus.auth === 'INVALID')) {\n                _context.next = 10;\n                break;\n              }\n\n              throw new HttpsError('unauthenticated', 'Unauthenticated');\n\n            case 10:\n              instanceId = req.header('Firebase-Instance-ID-Token');\n\n              if (instanceId) {\n                // Validating the token requires an http request, so we don't do it.\n                // If the user wants to use it for something, it will be validated then.\n                // Currently, the only real use case for this token is for sending\n                // pushes with FCM. In that case, the FCM APIs will validate the token.\n                context.instanceIdToken = req.header('Firebase-Instance-ID-Token');\n              }\n\n              data = decode(req.body.data);\n              _context.next = 15;\n              return handler(data, context);\n\n            case 15:\n              result = _context.sent;\n              // Encode the result as JSON to preserve types like Dates.\n              result = encode(result); // If there was some result, encode it in the body.\n\n              responseBody = {\n                result: result\n              };\n              res.status(200).send(responseBody);\n              _context.next = 27;\n              break;\n\n            case 21:\n              _context.prev = 21;\n              _context.t0 = _context[\"catch\"](0);\n\n              if (!(_context.t0 instanceof HttpsError)) {\n                // This doesn't count as an 'explicit' error.\n                logger_1.error('Unhandled error', _context.t0);\n                _context.t0 = new HttpsError('internal', 'INTERNAL');\n              }\n\n              status = _context.t0.httpErrorCode.status;\n              body = {\n                error: _context.t0.toJSON()\n              };\n              res.status(status).send(body);\n\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 21]]);\n    }));\n\n    return function func(_x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }(); // Wrap the function with a cors handler.\n\n\n  var corsFunc = function corsFunc(req, res) {\n    return corsHandler(req, res, function () {\n      return func(req, res);\n    });\n  };\n\n  corsFunc.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n    httpsTrigger: {},\n    labels: {\n      'deployment-callable': 'true'\n    }\n  });\n  corsFunc.run = handler;\n  return corsFunc;\n}\n\nexports._onCallWithOptions = _onCallWithOptions;","map":null,"metadata":{},"sourceType":"script"}