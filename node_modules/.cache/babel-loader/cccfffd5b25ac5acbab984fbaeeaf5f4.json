{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvar _objectSpread = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\Documents\\\\Course 2020\\\\React-Water\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.optionsToTrigger = exports.makeCloudFunction = exports.Change = void 0;\n\nvar _ = require(\"lodash\");\n\nvar logger_1 = require(\"./logger\");\n\nvar function_configuration_1 = require(\"./function-configuration\");\n/** @hidden */\n\n\nvar WILDCARD_REGEX = new RegExp('{[^/{}]*}', 'g');\n/**\n * The Functions interface for events that change state, such as\n * Realtime Database or Cloud Firestore `onWrite` and `onUpdate`.\n *\n * For more information about the format used to construct `Change` objects, see\n * [`cloud-functions.ChangeJson`](/docs/reference/functions/cloud_functions_.changejson).\n *\n */\n\nvar Change = function Change(before, after) {\n  _classCallCheck(this, Change);\n\n  this.before = before;\n  this.after = after;\n};\n\nexports.Change = Change;\n\n(function (Change) {\n  /** @hidden */\n  function reinterpretCast(x) {\n    return x;\n  }\n  /**\n   * @hidden\n   * Factory method for creating a Change from a `before` object and an `after`\n   * object.\n   */\n\n\n  function fromObjects(before, after) {\n    return new Change(before, after);\n  }\n\n  Change.fromObjects = fromObjects;\n  /**\n   * @hidden\n   * Factory method for creating a Change from a JSON and an optional customizer\n   * function to be applied to both the `before` and the `after` fields.\n   */\n\n  function fromJSON(json) {\n    var customizer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : reinterpretCast;\n\n    var before = _objectSpread({}, json.before);\n\n    if (json.fieldMask) {\n      before = applyFieldMask(before, json.after, json.fieldMask);\n    }\n\n    return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));\n  }\n\n  Change.fromJSON = fromJSON;\n  /** @hidden */\n\n  function applyFieldMask(sparseBefore, after, fieldMask) {\n    var before = _objectSpread({}, after);\n\n    var masks = fieldMask.split(',');\n    masks.forEach(function (mask) {\n      var val = _.get(sparseBefore, mask);\n\n      if (typeof val === 'undefined') {\n        _.unset(before, mask);\n      } else {\n        _.set(before, mask, val);\n      }\n    });\n    return before;\n  }\n\n  Change.applyFieldMask = applyFieldMask;\n})(Change = exports.Change || (exports.Change = {}));\n/** @hidden */\n\n\nfunction makeCloudFunction(_ref) {\n  var _ref$after = _ref.after,\n      after = _ref$after === void 0 ? function () {} : _ref$after,\n      _ref$before = _ref.before,\n      before = _ref$before === void 0 ? function () {} : _ref$before,\n      contextOnlyHandler = _ref.contextOnlyHandler,\n      _ref$dataConstructor = _ref.dataConstructor,\n      dataConstructor = _ref$dataConstructor === void 0 ? function (raw) {\n    return raw.data;\n  } : _ref$dataConstructor,\n      eventType = _ref.eventType,\n      handler = _ref.handler,\n      _ref$labels = _ref.labels,\n      labels = _ref$labels === void 0 ? {} : _ref$labels,\n      legacyEventType = _ref.legacyEventType,\n      _ref$options = _ref.options,\n      options = _ref$options === void 0 ? {} : _ref$options,\n      provider = _ref.provider,\n      service = _ref.service,\n      triggerResource = _ref.triggerResource;\n\n  var cloudFunction = function cloudFunction(data, context) {\n    if (legacyEventType && context.eventType === legacyEventType) {\n      /*\n       * v1beta1 event flow has different format for context, transform them to\n       * new format.\n       */\n      context.eventType = provider + '.' + eventType;\n      context.resource = {\n        service: service,\n        name: context.resource\n      };\n    }\n\n    var event = {\n      data: data,\n      context: context\n    };\n\n    if (provider === 'google.firebase.database') {\n      context.authType = _detectAuthType(event);\n\n      if (context.authType !== 'ADMIN') {\n        context.auth = _makeAuth(event, context.authType);\n      } else {\n        delete context.auth;\n      }\n    }\n\n    if (triggerResource() == null) {\n      Object.defineProperty(context, 'params', {\n        get: function get() {\n          throw new Error('context.params is not available when using the handler namespace.');\n        }\n      });\n    } else {\n      context.params = context.params || _makeParams(context, triggerResource);\n    }\n\n    before(event);\n    var promise;\n\n    if (labels && labels['deployment-scheduled']) {\n      // Scheduled function do not have meaningful data, so exclude it\n      promise = contextOnlyHandler(context);\n    } else {\n      var dataOrChange = dataConstructor(event);\n      promise = handler(dataOrChange, context);\n    }\n\n    if (typeof promise === 'undefined') {\n      logger_1.warn('Function returned undefined, expected Promise or value');\n    }\n\n    return Promise.resolve(promise).then(function (result) {\n      after(event);\n      return result;\n    }).catch(function (err) {\n      after(event);\n      return Promise.reject(err);\n    });\n  };\n\n  Object.defineProperty(cloudFunction, '__trigger', {\n    get: function get() {\n      if (triggerResource() == null) {\n        return {};\n      }\n\n      var trigger = _.assign(optionsToTrigger(options), {\n        eventTrigger: {\n          resource: triggerResource(),\n          eventType: legacyEventType || provider + '.' + eventType,\n          service: service\n        }\n      });\n\n      if (!_.isEmpty(labels)) {\n        trigger.labels = labels;\n      }\n\n      return trigger;\n    }\n  });\n  cloudFunction.run = handler || contextOnlyHandler;\n  return cloudFunction;\n}\n\nexports.makeCloudFunction = makeCloudFunction;\n/** @hidden */\n\nfunction _makeParams(context, triggerResourceGetter) {\n  if (context.params) {\n    // In unit testing, user may directly provide `context.params`.\n    return context.params;\n  }\n\n  if (!context.resource) {\n    // In unit testing, `resource` may be unpopulated for a test event.\n    return {};\n  }\n\n  var triggerResource = triggerResourceGetter();\n  var wildcards = triggerResource.match(WILDCARD_REGEX);\n  var params = {};\n\n  if (wildcards) {\n    var triggerResourceParts = _.split(triggerResource, '/');\n\n    var eventResourceParts = _.split(context.resource.name, '/');\n\n    _.forEach(wildcards, function (wildcard) {\n      var wildcardNoBraces = wildcard.slice(1, -1);\n\n      var position = _.indexOf(triggerResourceParts, wildcard);\n\n      params[wildcardNoBraces] = eventResourceParts[position];\n    });\n  }\n\n  return params;\n}\n/** @hidden */\n\n\nfunction _makeAuth(event, authType) {\n  if (authType === 'UNAUTHENTICATED') {\n    return null;\n  }\n\n  return {\n    uid: _.get(event, 'context.auth.variable.uid'),\n    token: _.get(event, 'context.auth.variable.token')\n  };\n}\n/** @hidden */\n\n\nfunction _detectAuthType(event) {\n  if (_.get(event, 'context.auth.admin')) {\n    return 'ADMIN';\n  }\n\n  if (_.has(event, 'context.auth.variable')) {\n    return 'USER';\n  }\n\n  return 'UNAUTHENTICATED';\n}\n/** @hidden */\n\n\nfunction optionsToTrigger(options) {\n  var trigger = {};\n\n  if (options.regions) {\n    trigger.regions = options.regions;\n  }\n\n  if (options.failurePolicy !== undefined) {\n    switch (options.failurePolicy) {\n      case false:\n        trigger.failurePolicy = undefined;\n        break;\n\n      case true:\n        trigger.failurePolicy = function_configuration_1.DEFAULT_FAILURE_POLICY;\n        break;\n\n      default:\n        trigger.failurePolicy = options.failurePolicy;\n    }\n  }\n\n  if (options.timeoutSeconds) {\n    trigger.timeout = options.timeoutSeconds.toString() + 's';\n  }\n\n  if (options.memory) {\n    var memoryLookup = {\n      '128MB': 128,\n      '256MB': 256,\n      '512MB': 512,\n      '1GB': 1024,\n      '2GB': 2048,\n      '4GB': 4096,\n      '8GB': 8192\n    };\n    trigger.availableMemoryMb = _.get(memoryLookup, options.memory);\n  }\n\n  if (options.schedule) {\n    trigger.schedule = options.schedule;\n  }\n\n  if (options.minInstances) {\n    trigger.minInstances = options.minInstances;\n  }\n\n  if (options.maxInstances) {\n    trigger.maxInstances = options.maxInstances;\n  }\n\n  if (options.ingressSettings) {\n    trigger.ingressSettings = options.ingressSettings;\n  }\n\n  if (options.vpcConnector) {\n    trigger.vpcConnector = options.vpcConnector;\n  }\n\n  if (options.vpcConnectorEgressSettings) {\n    trigger.vpcConnectorEgressSettings = options.vpcConnectorEgressSettings;\n  }\n\n  if (options.serviceAccount) {\n    if (options.serviceAccount === 'default') {// Do nothing, since this is equivalent to not setting serviceAccount.\n    } else if (options.serviceAccount.endsWith('@')) {\n      if (!process.env.GCLOUD_PROJECT) {\n        throw new Error(\"Unable to determine email for service account '\".concat(options.serviceAccount, \"' because process.env.GCLOUD_PROJECT is not set.\"));\n      }\n\n      trigger.serviceAccountEmail = \"\".concat(options.serviceAccount).concat(process.env.GCLOUD_PROJECT, \".iam.gserviceaccount.com\");\n    } else if (options.serviceAccount.includes('@')) {\n      trigger.serviceAccountEmail = options.serviceAccount;\n    } else {\n      throw new Error(\"Invalid option for serviceAccount: '\".concat(options.serviceAccount, \"'. Valid options are 'default', a service account email, or '{serviceAccountName}@'\"));\n    }\n  }\n\n  return trigger;\n}\n\nexports.optionsToTrigger = optionsToTrigger;","map":null,"metadata":{},"sourceType":"script"}